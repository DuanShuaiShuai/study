<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>正弦曲线</title>
    <link rel="icon" href="https://img.kaikeba.com/kkb_portal_icon.ico" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas"></canvas>
    <script id="vertexShader" type="x-shader/x-vertex">
      attribute vec4 a_Position;
      attribute vec4 a_Color;
      uniform mat4 u_ViewMatrix;
      varying vec4 v_Color;
      void main(){
        gl_Position = u_ViewMatrix*a_Position;
        gl_PointSize=3.0;
        v_Color=a_Color;
      }
    </script>
    <script id="fragmentShader" type="x-shader/x-fragment">
      precision mediump float;
      varying vec4 v_Color;
      void main(){
          gl_FragColor=v_Color;
      }
    </script>
    <script type="module">
      import {
        initShaders,
        getMousePosInWebgl,
        ScaleLinear,
      } from "./utils/Utils.js";
      import Poly from "./utils/Poly.js";
      import {
        Matrix4,
        Vector3,
        Quaternion,
        Plane,
        Color,
        Ray,
      } from "https://unpkg.com/three/build/three.module.js";

      const canvas = document.getElementById("canvas");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const gl = canvas.getContext("webgl");

      const vsSource = document.getElementById("vertexShader").innerText;
      const fsSource = document.getElementById("fragmentShader").innerText;
      initShaders(gl, vsSource, fsSource);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);

      const viewMatrix = new Matrix4().lookAt(
        new Vector3(0.2, 0.3, 1),
        new Vector3(),
        new Vector3(0, 1, 0)
      );

      const [minPosX, maxPosX, minPosZ, maxPosZ] = [-0.7, 0.8, -1, 1];
      const [minAngX, maxAngX, minAngZ, maxAngZ] = [
        0,
        Math.PI * 4,
        0,
        Math.PI * 2,
      ];
      const scalerX = ScaleLinear(minPosX, minAngX, maxPosX, maxAngX);
      const scalerZ = ScaleLinear(minPosZ, minAngZ, maxPosZ, maxAngZ);
      const [a1, a2] = [0.1, 0.03];
      const a12 = a1 + a2;
      const [minY, maxY] = [-a12, a12];
      const [minH, maxH] = [0.15, 0.5];
      const scalerC = ScaleLinear(minY, minH, maxY, maxH);
      const color = new Color();
      const [rows, cols] = [50, 50];
      const a_Position = { size: 3, index: 0 };
      const a_Color = { size: 4, index: 3 };
      const categorySize = a_Position.size + a_Color.size;
      // 透明
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
      // 建立基于行列式获取顶点索引的方法
      const getInd = GetIndexInGrid(cols, categorySize);
      function GetIndexInGrid(w, size) {
        return function (x, y) {
          return (y * w + x) * size;
        };
      }
      //获取顶点阵列和三角形的顶点索引集合
      const { vertices, indexes } = crtBaseData(
        cols,
        rows,
        minPosX,
        maxPosX,
        minPosZ,
        maxPosZ
      );
      const wave = new Poly({
        gl,
        source: getSource(vertices, indexes, categorySize),
        uniforms: {
          u_ViewMatrix: {
            type: "uniformMatrix4fv",
            value: viewMatrix.elements,
          },
        },
        attributes: {
          a_Position,
          a_Color,
        },
      });

      render();
      function render() {
        gl.clear(gl.COLOR_BUFFER_BIT);
        // wave.draw();
        // wave.draw("LINES");
        wave.draw("TRIANGLES");
      }
      let offset = 0;
      !(function ani() {
        offset += 0.08;
        updateSource(offset);
        wave.updateAttribute();
        render();
        requestAnimationFrame(ani);
      })();
      //更新顶点高度
      function updateSource(offset = 0) {
        const { source, categorySize } = wave;
        for (let i = 0; i < source.length; i += categorySize) {
          const [posX, posZ] = [source[i], source[i + 2]];
          const angZ = scalerZ(posZ);
          const Omega = 2;
          const a = Math.sin(angZ) * a1 + a2;
          const phi = scalerX(posX) + offset;
          const y = SinFn(a, Omega, phi)(angZ);
          source[i + 1] = y;
          const h = scalerC(y);
          const { r, g, b } = color.setHSL(h, 1, 0.6);
          source[i + 3] = r;
          source[i + 4] = g;
          source[i + 5] = b;
        }
      }

      /* 正弦函数 */
      function SinFn(a, Omega, phi) {
        return function (x) {
          return a * Math.sin(Omega * x + phi);
        };
      }
      function crtBaseData(cols, rows, minPosX, maxPosX, minPosZ, maxPosZ) {
        const vertices = [];
        const indexes = [];
        const spaceZ = (maxPosZ - minPosZ) / rows;
        const spaceX = (maxPosX - minPosX) / cols;
        for (let z = 0; z < rows; z++) {
          for (let x = 0; x < cols; x++) {
            const px = x * spaceX + minPosX;
            const pz = z * spaceZ + minPosZ;
            vertices.push(px, 0, pz, 1, 1, 1, 0.5);
            if (z && x) {
              const [x0, z0] = [x - 1, z - 1];
              indexes.push(
                getInd(x0, z0),
                getInd(x, z0),
                getInd(x, z),
                getInd(x0, z0),
                getInd(x, z),
                getInd(x0, z)
              );
            }
          }
        }
        return { vertices, indexes };
      }
      // 建立顶点集合
      function getSource(vertices, indexes, categorySize) {
        const arr = [];
        indexes.forEach((i) => {
          arr.push(...vertices.slice(i, i + categorySize));
        });
        console.log(arr);
        return arr;
      }
    </script>
  </body>
</html>
